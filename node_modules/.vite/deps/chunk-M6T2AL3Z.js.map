{
  "version": 3,
  "sources": ["../../@restart/hooks/esm/useCommittedRef.js", "../../@restart/hooks/esm/useEventCallback.js", "../../@restart/hooks/esm/useMounted.js", "../../@restart/hooks/esm/usePrevious.js"],
  "sourcesContent": ["import { useEffect, useRef } from 'react';\n/**\n * Creates a `Ref` whose value is updated in an effect, ensuring the most recent\n * value is the one rendered with. Generally only required for Concurrent mode usage\n * where previous work in `render()` may be discarded before being used.\n *\n * This is safe to access in an event handler.\n *\n * @param value The `Ref` value\n */\n\nfunction useCommittedRef(value) {\n  var ref = useRef(value);\n  useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\nexport default useCommittedRef;", "import { useCallback } from 'react';\nimport useCommittedRef from './useCommittedRef';\nexport default function useEventCallback(fn) {\n  var ref = useCommittedRef(fn);\n  return useCallback(function () {\n    return ref.current && ref.current.apply(ref, arguments);\n  }, [ref]);\n}", "import { useRef, useEffect } from 'react';\n/**\n * Track whether a component is current mounted. Generally less preferable than\n * properlly canceling effects so they don't run after a component is unmounted,\n * but helpful in cases where that isn't feasible, such as a `Promise` resolution.\n *\n * @returns a function that returns the current isMounted state of the component\n *\n * ```ts\n * const [data, setData] = useState(null)\n * const isMounted = useMounted()\n *\n * useEffect(() => {\n *   fetchdata().then((newData) => {\n *      if (isMounted()) {\n *        setData(newData);\n *      }\n *   })\n * })\n * ```\n */\n\nexport default function useMounted() {\n  var mounted = useRef(true);\n  var isMounted = useRef(function () {\n    return mounted.current;\n  });\n  useEffect(function () {\n    mounted.current = true;\n    return function () {\n      mounted.current = false;\n    };\n  }, []);\n  return isMounted.current;\n}", "import { useEffect, useRef } from 'react';\n/**\n * Store the last of some value. Tracked via a `Ref` only updating it\n * after the component renders.\n *\n * Helpful if you need to compare a prop value to it's previous value during render.\n *\n * ```ts\n * function Component(props) {\n *   const lastProps = usePrevious(props)\n *\n *   if (lastProps.foo !== props.foo)\n *     resetValueFromProps(props.foo)\n * }\n * ```\n *\n * @param value the value to track\n */\n\nexport default function usePrevious(value) {\n  var ref = useRef(null);\n  useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n}"],
  "mappings": ";;;;;;;;AAAA,mBAAkC;AAWlC,SAAS,gBAAgB,OAAO;AAC9B,MAAI,UAAM,qBAAO,KAAK;AACtB,8BAAU,WAAY;AACpB,QAAI,UAAU;AAAA,EAChB,GAAG,CAAC,KAAK,CAAC;AACV,SAAO;AACT;AAEA,IAAO,0BAAQ;;;ACnBf,IAAAA,gBAA4B;AAEb,SAAR,iBAAkC,IAAI;AAC3C,MAAI,MAAM,wBAAgB,EAAE;AAC5B,aAAO,2BAAY,WAAY;AAC7B,WAAO,IAAI,WAAW,IAAI,QAAQ,MAAM,KAAK,SAAS;AAAA,EACxD,GAAG,CAAC,GAAG,CAAC;AACV;;;ACPA,IAAAC,gBAAkC;AAsBnB,SAAR,aAA8B;AACnC,MAAI,cAAU,sBAAO,IAAI;AACzB,MAAI,gBAAY,sBAAO,WAAY;AACjC,WAAO,QAAQ;AAAA,EACjB,CAAC;AACD,+BAAU,WAAY;AACpB,YAAQ,UAAU;AAClB,WAAO,WAAY;AACjB,cAAQ,UAAU;AAAA,IACpB;AAAA,EACF,GAAG,CAAC,CAAC;AACL,SAAO,UAAU;AACnB;;;AClCA,IAAAC,gBAAkC;AAmBnB,SAAR,YAA6B,OAAO;AACzC,MAAI,UAAM,sBAAO,IAAI;AACrB,+BAAU,WAAY;AACpB,QAAI,UAAU;AAAA,EAChB,CAAC;AACD,SAAO,IAAI;AACb;",
  "names": ["import_react", "import_react", "import_react"]
}
